/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package paging.core.tasks;

import com.jme3.bullet.control.PhysicsControl;
import com.jme3.bullet.control.RigidBodyControl;
import com.jme3.bullet.util.CollisionShapeFactory;
import com.jme3.math.Vector3f;
import com.jme3.scene.Geometry;
import java.util.concurrent.Future;
import paging.core.Delegator;
import paging.core.PagingManager.LOD;
import paging.core.spatials.ManagedMesh;
import paging.core.spatials.ManagedNode;

/**
 *
 * @author t0neg0d
 */
public class DelegatorTask {
	public static enum STAGE {
		BEGIN,
		CACHED,
		PHYSICS,
		COMPLETE
	}
	
	private Delegator delegator;
	private Vector3f position;
	private ManagedNode node = null;
	private ManagedNode dependentNode = null;
	private ManagedMesh mesh = null;
	private PhysicsControl physicsNode = null;
	private Geometry geom = null;
	private STAGE stage = STAGE.BEGIN;
	private Future future = null;
	private LOD detailHigh, detailLow;
	private LOD nextLOD = LOD.LOD_1;
	/**
	 * Creates a new DelegatorTask
	 * @param delegator Pointer to the delegator that created the task
	 * @param position The Vector3f position associated with the tile being created/managed
	 * @param detailHigh The closest/highest LOD supported
	 * @param detailLow The furtherest/lowest LOD supported
	 */
	public DelegatorTask(Delegator delegator, final Vector3f position, LOD detailHigh, LOD detailLow) {
		this.delegator = delegator;
		this.position = position;
		this.detailHigh = detailHigh;
		this.detailLow = detailLow;
		this.nextLOD = detailLow;
	}
	/**
	 * Returns the  Vector3f poisition the task is registered with
	 * @return 
	 */
	public Vector3f getPosition() {
		return this.position;
	}
	/**
	 * Executed upon completion of the Future for tile creation. This retrieves the
	 * ManagedMesh returned from the Future, the Geometry returned by the delegator
	 * and creates a ManagedNode and places them accordingly.
	 */
	public void finialize() {
		String name =	delegator.getUID() + ":" + 
						position.getX() + ":" + 
						position.getY() + ":" + 
						position.getZ() + ":";
		node = new ManagedNode();
		node.setName(name + "Node");
		geom = delegator.getGeometry();
		geom.setName(name + "Geom");
		geom.setMesh(mesh);
		node.attachChild(geom);
		node.setLocalTranslation(position);
	}
	/**
	 * Returns the ManagedNode created by finalize
	 * @return ManagedNode node
	 */
	public ManagedNode getNode() {
		return this.node;
	}
	/**
	 * Sets the ManagedNode associated with this DelegatorTask.  This is used by 
	 * prepopulated Delegators
	 * @param node A pointer to the ManagedNode to associate with this task
	 */
	public void setNode(ManagedNode node) {
		this.node = node;
	}
	/**
	 * Returns the custom ManagedMesh created by this task
	 * @return ManagedMesh mesh
	 */
	public ManagedMesh getMesh() {
		return this.mesh;
	}
	/**
	 * Sets the ManagedMesh created by the Future associated with this task
	 * @param mesh ManagedMesh
	 */
	public void setMesh(ManagedMesh mesh) {
		this.mesh = mesh;
	}
	/**
	 * Returns a pointer to the Geometry created by the delegator associated with this task
	 * @return Geometry geom
	 */
	public Geometry getGeometry() {
		return this.geom;
	}
	/**
	 * Sets the Geometry retrieved from the delegator
	 * @param geom Geometry
	 */
	public void setGeometry(Geometry geom) {
		this.geom = geom;
	}
	/**
	 * Creates a RigidBodyControl for the task's ManagedMesh
	 */
	public void createPhysicsNode() {
		mesh.updateLOD(detailHigh);
		this.physicsNode = new RigidBodyControl(CollisionShapeFactory.createMeshShape(node), 0);
		mesh.updateLOD(detailLow);
		node.addControl(physicsNode);
	}
	/**
	 * Returns the PhysicsControl generated by createPhysicsNode()
	 * @return 
	 */
	public PhysicsControl getPhysicsNode() {
		return this.physicsNode;
	}
	/**
	 * Returns the current STAGE the task is at
	 * @return STAGE stage
	 */
	public STAGE getStage() {
		return this.stage;
	}
	/**
	 * Called by the delegator as it progresses through the tasks lifecycle
	 * @param stage STAGE
	 */
	public void setStage(STAGE stage) {
		this.stage = stage;
	}
	/**
	 * Stores the current Future being executed against the task
	 * @return Future future
	 */
	public Future getFuture() {
		return this.future;
	}
	/**
	 * Sets the current Future being executed against the task
	 * @param future Future
	 */
	public void setFuture(Future future) {
		this.future = future;
	}
	/**
	 * Stores the next LOD update to perform against this task.
	 * @param lod PagingManager.LOD
	 */
	public void setNextLOD(LOD lod) {
		this.nextLOD = lod;
	}
	/**
	 * Retrieves the next/last LOD update to perform against this task
	 * @return PagingManager.LOD
	 */
	public LOD getNextLOD() {
		return this.nextLOD;
	}
	/**
	 * Retrieves the parent delegator's ManagedNode this task is dependent
	 * on
	 * @return 
	 */
	public ManagedNode getDependentNode() {
		return this.dependentNode;
	}
	/**
	 * Sets a pointer to the ManagedNode created by the parent delegator 
	 * the current task is dependent on
	 * @param node ManagedNode
	 */
	public void setDependentNode(ManagedNode node) {
		this.dependentNode = node;
	}
	
	
}
